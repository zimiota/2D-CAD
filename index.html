<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta name="format-detection" content="telephone=no">
  <title>2D-CAD Prototype</title>
  <style>
    body { margin: 0; overflow: auto; font-family: sans-serif; background: #f5f7fb; }
    canvas { display: block; }
.tabs-wrapper {
  margin-top: 14px;
}

#tabs { display:flex; background:#ddd; padding: 54px 10px; gap: 8px; }
.tab-button {
  flex: 1;
  padding: 63px 18px;
  cursor: pointer;
  border: none;
  background: #ccc;
  font-size: 36px;
}
.tab-button.active { background:#fff; border-bottom:2px solid #000; }
.tab-content { display:none; }
.tab-content.active { display:block; }

.tab-section {
  max-width: 980px;
  margin: 20px auto;
  padding: 18px 22px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  font-size: 32px;
  line-height: 1.4;
}

.tab-section h2 {
  margin: 0 0 12px;
  font-size: 36px;
}

.input-row {
  display: grid;
  grid-template-columns: 180px 220px 1fr;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
}

.input-row input[type="number"] {
  font-size: 32px;
  padding: 8px 12px;
}

.input-row input[type="range"] {
  width: 100%;
  accent-color: #1f73ff;
}

.result-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 16px;
  margin-top: 12px;
}

.result-card {
  padding: 12px 16px;
  background: #f8f9fb;
  border-radius: 10px;
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.04);
}

.result-card .label {
  font-weight: bold;
  color: #1f2d3d;
}

.result-card .value {
  font-size: 38px;
  display: block;
  margin-top: 6px;
  letter-spacing: 0.02em;
}

    #calc1 .tab-section h2 {
      margin-bottom: 18px;
    }
    #calc1 .input-row {
      grid-template-columns: 240px 240px 1fr;
      margin-bottom: 20px;
    }
    #calc1 .input-row input[type="number"] {
      font-size: 36px;
      padding: 10px 14px;
    }
    #calc1 .input-row input[type="range"] {
      accent-color: #1f73ff;
    }
    #calc1 .input-row .note {
      color: #445;
      font-size: 24px;
    }
    #calc1 .canvas-frame {
      margin-top: 28px;
      background: #f8f9fb;
      border: 1px solid #d5dce5;
      border-radius: 14px;
      padding: 16px;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.04);
    }
    #cad {
      width: 100%;
      height: 640px;
      background: #fff;
      border-radius: 10px;
    }

    #calc1 {
      font-size: 48px;
    }
    #angle-panel label {
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 48px;
    }
    #angle-panel input[type="number"] {
      font-size: 48px;
      padding: 12px 18px;
    }
    #angle-panel input[type="range"] {
      width: 360px;
      accent-color: #1f73ff;
    }

#tri-center {
  width:100%;
  display:flex;
  justify-content:center;
  margin-top:20px;
}
#triView {
  border:1px solid #aaa;
  background:#fff;
}
    .triangle {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-top: 100px solid #c0d0ff;
    }
    #angle2-panel label {
      font-size: 32px;
    }
    #angle2-panel input {
      font-size: 32px;
      padding: 8px 12px;
    }
    #angle2-panel > div {
      font-size: 32px;
    }
    #angle2-panel #phiVal,
    #angle2-panel #alpha {
      font-size: 32px;
    }
  </style>
</head>
<body>
  <div class="tabs-wrapper">
    <div id="tabs">
      <button class="tab-button active" data-tab="calc1">A/B CAD</button>
      <button class="tab-button" data-tab="calc2">2.5D Angle</button>
      <button class="tab-button" data-tab="calc3">TouchPoint</button>
    </div>
  </div>
<div id="calc1" class="tab-content active">
  <div class="tab-section">
    <h2>円の角度と半径から A/B を描画</h2>
    <div class="input-row">
      <div>角度（度数）:</div>
      <input id="angle-input" type="number" value="0" min="0" max="90">
      <input id="angle-slider" type="range" value="0" min="0" max="90">
    </div>
    <div class="input-row">
      <div>半径:</div>
      <input id="radius-input" type="number" value="3.0" min="0" step="0.1" max="999">
      <div class="note">小数第 1 位で調整</div>
    </div>
    <div class="canvas-frame">
      <canvas id="cad"></canvas>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("cad");
    const ctx = canvas.getContext("2d");
    const canvasFrame = document.querySelector("#calc1 .canvas-frame");
    const angleInput = document.getElementById("angle-input");
    const angleSlider = document.getElementById("angle-slider");
    const radiusInput = document.getElementById("radius-input");
    const defaultAngleDeg = 0;
    let angleDeg = Number(angleInput.value) || 0;
    const basePixelRadius = 240;
    let logicalRadius = Number(radiusInput.value) || 3;
    const setAngle = (value) => {
      angleDeg = Number(value) || 0;
      angleInput.value = angleDeg;
      angleSlider.value = angleDeg;
      draw();
    };
    angleInput.addEventListener("input", () => setAngle(angleInput.value));
    angleSlider.addEventListener("input", () => setAngle(angleSlider.value));
    const updateRadiusFromInput = () => {
      const radiusValue = Number(radiusInput.value);
      if (Number.isFinite(radiusValue)) {
        logicalRadius = radiusValue;
        draw();
      }
    };

    const finalizeRadiusInput = () => {
      const radiusValue = Number(radiusInput.value);
      const roundedRadius = Number.isFinite(radiusValue)
        ? Math.round(radiusValue * 10) / 10
        : 0;
      logicalRadius = roundedRadius;
      radiusInput.value = roundedRadius.toFixed(1);
      draw();
    };

    radiusInput.addEventListener("input", updateRadiusFromInput);
    radiusInput.addEventListener("blur", finalizeRadiusInput);

    function resize() {
      if (!canvasFrame) return;

      const frameRect = canvasFrame.getBoundingClientRect();
      const frameStyle = getComputedStyle(canvasFrame);
      const paddingX = parseFloat(frameStyle.paddingLeft) + parseFloat(frameStyle.paddingRight);
      const paddingY = parseFloat(frameStyle.paddingTop) + parseFloat(frameStyle.paddingBottom);
      const availableWidth = Math.max(320, frameRect.width - paddingX);
      const desiredHeight = Math.max(520, Math.min(760, availableWidth * 0.6)) + paddingY;

      canvas.width = availableWidth;
      canvas.height = desiredHeight - paddingY;
      canvas.style.height = `${canvas.height}px`;
      draw();
    }
    window.addEventListener("resize", resize);

    const computeAngleParams = (deg) => {
      const angleRad = (90 + deg) * Math.PI / 180;
      const half = angleRad / 2;
      const sinHalfRaw = Math.sin(half);
      const sinHalf = Math.abs(sinHalfRaw) < 1e-6 ? (sinHalfRaw >= 0 ? 1e-6 : -1e-6) : sinHalfRaw;
      return { angleRad, half, sinHalf };
    };

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000";

      const centerX = canvas.width / 2;
      const centerY = canvas.height * 0.42;
      // 円のピクセル半径はキャンバスに収まるようスケーリング
      const baseLogicalRadius = 3;
      // 入力角度は「垂直からの傾き」として扱い、
      // 内部計算では (90° + 入力角度) を用いる
      const { angleRad, half, sinHalf } = computeAngleParams(angleDeg);

      const dimensionRadius = logicalRadius || 0;
      // A = r * cot(θ/2) = r * cos(θ/2) / sin(θ/2)
      const dimensionA = dimensionRadius * Math.cos(half) / sinHalf;
      // B は従来通り: B = r * (1 + cos θ)
      const dimensionB = dimensionRadius * (1 + Math.cos(angleRad));

      const margin = 36;
      const computeGeometry = (radius, params) => {
        const { angleRad: angleRadLocal, half: halfLocal, sinHalf: sinHalfLocal } = params;
        const extension = radius * 2;
        const d = radius / sinHalfLocal;
        const cornerX = centerX - d * Math.cos(halfLocal);
        const cornerY = centerY - d * Math.sin(halfLocal);
        const tangentLength = Math.sqrt(Math.max(0, d * d - radius * radius));
        const tangentX = cornerX + tangentLength * Math.cos(angleRadLocal);
        const tangentY = cornerY + tangentLength * Math.sin(angleRadLocal);
        const horizontalTangentX = cornerX + tangentLength;

        const angledLineEnd = {
          x: cornerX + (tangentLength + extension) * Math.cos(angleRadLocal),
          y: cornerY + (tangentLength + extension) * Math.sin(angleRadLocal),
        };
        const horizontalLineEnd = { x: horizontalTangentX + extension, y: cornerY };
        const bottomY = centerY + radius;

        const lineDx = tangentX - cornerX;
        const lineDy = tangentY - cornerY;
        const lineLen = Math.hypot(lineDx, lineDy) || 1;
        const leftNormal = { x: -lineDy / lineLen, y: lineDx / lineLen };
        const bBaseX = (cornerX + tangentX) / 2;
        const bBaseY = (cornerY + tangentY) / 2 - 10;
        const bOffset = 40;
        const bPosX = bBaseX + leftNormal.x * bOffset;
        const bPosY = bBaseY + leftNormal.y * bOffset;

        const aTextPos = { x: (cornerX + centerX) / 2, y: cornerY - 20 };

        const minX = Math.min(
          centerX - radius,
          centerX + radius,
          cornerX,
          horizontalLineEnd.x,
          angledLineEnd.x,
          tangentX,
          aTextPos.x,
          bPosX,
        );
        const maxX = Math.max(
          centerX - radius,
          centerX + radius,
          cornerX,
          horizontalLineEnd.x,
          angledLineEnd.x,
          tangentX,
          aTextPos.x,
          bPosX,
        );
        const minY = Math.min(
          centerY - radius,
          centerY + radius,
          cornerY,
          angledLineEnd.y,
          bottomY,
          aTextPos.y,
          bPosY,
        );
        const maxY = Math.max(
          centerY - radius,
          centerY + radius,
          cornerY,
          angledLineEnd.y,
          bottomY,
          aTextPos.y,
          bPosY,
        );

        return {
          radius,
          extension,
          cornerX,
          cornerY,
          tangentX,
          tangentY,
          horizontalLineEnd,
          angledLineEnd,
          bottomY,
          bPosX,
          bPosY,
          aTextPos,
          leftNormal,
          bounds: { minX, maxX, minY, maxY },
        };
      };

      const baseGeometry = computeGeometry(basePixelRadius, computeAngleParams(defaultAngleDeg));
      const boundsWidth = baseGeometry.bounds.maxX - baseGeometry.bounds.minX;
      const boundsHeight = baseGeometry.bounds.maxY - baseGeometry.bounds.minY;
      const safeWidth = canvas.width - margin * 2;
      const safeHeight = canvas.height - margin * 2;
      const scale = Math.min(
        1,
        safeWidth / Math.max(boundsWidth, 1),
        safeHeight / Math.max(boundsHeight, 1)
      );
      const radius = basePixelRadius * (Number.isFinite(scale) && scale > 0 ? scale : 1);
      const geometry = computeGeometry(radius, { angleRad, half, sinHalf });

      // 円
      ctx.beginPath();
      ctx.arc(centerX, centerY, geometry.radius, 0, Math.PI * 2);
      ctx.stroke();

      // 垂直線（中心から水平線まで）
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX, geometry.cornerY);
      ctx.stroke();

      // 右向きの線（接点からさらに延長）
      ctx.beginPath();
      ctx.moveTo(geometry.cornerX, geometry.cornerY);
      ctx.lineTo(geometry.horizontalLineEnd.x, geometry.horizontalLineEnd.y);
      ctx.stroke();

      // α度の線（接点からさらに延長）
      ctx.beginPath();
      ctx.moveTo(geometry.cornerX, geometry.cornerY);
      ctx.lineTo(geometry.angledLineEnd.x, geometry.angledLineEnd.y);
      ctx.stroke();

      // A/B 寸法表示
      ctx.save();
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#333";
      ctx.textBaseline = "middle";

      // A: 上側水平線中央
      ctx.textAlign = "center";
      ctx.fillText(
        `A: ${dimensionA.toFixed(3)}`,
        geometry.aTextPos.x,
        geometry.aTextPos.y
      );

      // B: 斜線の左側に固定オフセットで配置
      ctx.textAlign = geometry.leftNormal.x >= 0 ? "left" : "right";
      ctx.fillText(`B: ${dimensionB.toFixed(3)}`, geometry.bPosX, geometry.bPosY);

      ctx.restore();
    }

    resize();
  </script>
</div>
  <div id="calc2" class="tab-content">
  <div id="angle2-panel" style="margin: 10px auto; text-align: center; width: fit-content;">
    <label>θ（初期角度）: <input id="theta" type="number" min="0" max="90" value="20">°</label><br>
    <label>φ（回転角）: <input id="phi" type="range" min="0" max="90" value="0"> <span id="phiVal">0</span></label><br>
    <div>見かけ角 α（度）: <span id="alpha">---</span></div>
    <div style="font-size: 12px; margin-top: 6px; line-height: 1.5; text-align: left;">
      <div>・回転角度 φ は X 軸に対する回転指示角。</div>
      <div>・直角三角形は垂直辺（右辺）を軸に回転。</div>
      <div>・見かけ角 α は斜辺の傾き θ と φ の組み合わせで決まる正面からの角度。</div>
    </div>
  </div>
  <div id="tri-center">
    <canvas id="triView" width="500" height="400"></canvas>
  </div>
</div>
<div id="calc3" class="tab-content">
  <div class="tab-section">
    <h2>円の半径と角度から接点座標を計算</h2>
    <div class="input-row">
      <div>半径 (r):</div>
      <input id="tab3-radius-input" type="number" value="3.00" min="0.0" step="0.01">
      <input id="tab3-radius-slider" type="range" min="0.0" max="100" step="0.1" value="3.0">
    </div>
    <div class="input-row">
      <div>角度（度）:</div>
      <input id="tab3-theta-input" type="number" value="0.0" min="0" max="89.9" step="0.1">
      <input id="tab3-theta-slider" type="range" min="0" max="89.9" step="0.1" value="0.0">
    </div>
    <div class="input-row">
      <div>円底からの Y 座標 (C):</div>
      <input id="tab3-c-input" type="number" value="1.0" min="0.0" max="50" step="0.1">
      <input id="tab3-c-slider" type="range" min="0.0" max="50" step="0.1" value="1.0">
    </div>
    <div class="result-grid">
      <div class="result-card">
        <div class="label">A</div>
        <span class="value" id="tab3-a">---</span>
      </div>
      <div class="result-card">
        <div class="label">B</div>
        <span class="value" id="tab3-b">---</span>
      </div>
      <div class="result-card">
        <div class="label">X (C での斜線交点)</div>
        <span class="value" id="tab3-xc">---</span>
      </div>
    </div>
    <div style="margin-top: 10px; font-size: 22px; color: #445;">
      入力と出力はすべて小数点以下 3 位に丸めて表示します。角度 0° では円の右端に垂直線、角度が増えると右上へ傾きます。
    </div>
    <div id="tab3-diagram-wrapper" style="margin-top: 24px; text-align: center;">
      <canvas id="tab3-diagram" width="1100" height="760" style="max-width: 100%; border: 1px solid #ccc; background: #fafafa;"></canvas>
    </div>
  </div>
</div>

<script>
document.querySelectorAll(".tab-button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    btn.classList.add("active");
    document.getElementById(btn.dataset.tab).classList.add("active");
  });
});

const thetaInput = document.getElementById('theta');
const phiInput = document.getElementById('phi');

thetaInput.addEventListener('input', updateAngle2);
phiInput.addEventListener('input', updateAngle2);

function formatDMS(deg, secondsDecimals = 1) {
  const sign = deg < 0 ? '-' : '';
  const absDeg = Math.abs(deg);
  let d = Math.floor(absDeg);
  let minFloat = (absDeg - d) * 60;
  let m = Math.floor(minFloat);
  let s = (minFloat - m) * 60;

  const roundingFactor = 10 ** secondsDecimals;
  s = Math.round(s * roundingFactor) / roundingFactor;
  if (s >= 60) {
    s -= 60;
    m += 1;
  }
  if (m >= 60) {
    m -= 60;
    d += 1;
  }

  let sStr = s.toFixed(secondsDecimals);
  if (secondsDecimals > 0) {
    sStr = sStr.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
  }
  const [sInt, sFrac] = sStr.split('.');
  const secIntPadded = sInt.padStart(2, '0');
  const secFormatted = sFrac ? `${secIntPadded}.${sFrac}` : secIntPadded;

  const minFormatted = String(m).padStart(2, '0');
  return `${sign}${d}°${minFormatted}′${secFormatted}″`;
}

function updateAngle2() {
  const thetaDeg = parseFloat(thetaInput.value) || 0;
  const theta = thetaDeg * Math.PI / 180;
  const phiDeg = parseFloat(phiInput.value) || 0;
  const phi = phiDeg * Math.PI / 180;
  const alpha = Math.atan(Math.tan(theta) * Math.cos(phi)) * 180 / Math.PI;

  const displayedPhiDeg = 90 - phiDeg;

  document.getElementById('phiVal').innerText = formatDMS(displayedPhiDeg);
  document.getElementById('alpha').innerText = formatDMS(alpha);

  const canvas = document.getElementById('triView');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 直角は右下、垂直辺は右、斜辺は左になるように配置する
  // θ は垂直辺と斜辺のなす角として扱う
  const hypotenuse = 220;
  const vertical = hypotenuse * Math.cos(theta);
  const bottom = hypotenuse * Math.sin(theta);

  const cx = canvas.width / 2;
  const cy = canvas.height * 0.70;

  // 三角形の各頂点（回転前）
  const bottomRight = { x: cx + bottom / 2, y: cy }; // 直角
  const bottomLeft = { x: cx - bottom / 2, y: cy };  // 底辺左端（短辺側）
  const topRight = { x: bottomRight.x, y: cy - vertical }; // 垂直辺の上端

  // 垂直辺（右辺）を回転軸として扱う
  // 軸上の点（bottomRight, topRight）はそのままにし、左端のみ回転
  // ただし回転によって底辺の高さが変わらないよう、
  // y 座標は固定しつつ x のみを縮小させる（奥行き方向の圧縮を想定）
  const rotateAroundRightEdge = (point) => {
    const dx = point.x - bottomRight.x;
    return {
      x: bottomRight.x + dx * Math.cos(phi),
      y: point.y,
    };
  };

  const rpBottomRight = bottomRight;
  const rpTopRight = topRight;
  const rpBottomLeft = rotateAroundRightEdge(bottomLeft);

  ctx.beginPath();
  ctx.moveTo(rpBottomRight.x, rpBottomRight.y);
  ctx.lineTo(rpBottomLeft.x, rpBottomLeft.y);
  ctx.lineTo(rpTopRight.x, rpTopRight.y);
  ctx.closePath();
  ctx.fillStyle = '#c0d0ff';
  ctx.strokeStyle = '#003';
  ctx.lineWidth = 2;
  ctx.fill();
  ctx.stroke();

  // 回転軸である垂直辺を破線で示す
  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(rpBottomRight.x, rpBottomRight.y);
  ctx.lineTo(rpTopRight.x, rpTopRight.y);
  ctx.stroke();
  ctx.restore();

  // θ・φ・α の簡易ラベルを表示
  ctx.fillStyle = '#003';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(`θ: ${formatDMS(thetaDeg)}`, 20, 24);
  ctx.fillText(`φ: ${formatDMS(phiDeg)}`, 20, 42);
  ctx.fillText(`α: ${formatDMS(alpha)}`, 20, 60);
}
updateAngle2();

// ==== Tab3: 半径と角度から接点の A/B を計算 ====
const tab3RadiusInput = document.getElementById('tab3-radius-input');
const tab3RadiusSlider = document.getElementById('tab3-radius-slider');
const tab3ThetaInput = document.getElementById('tab3-theta-input');
const tab3ThetaSlider = document.getElementById('tab3-theta-slider');
const tab3CInput = document.getElementById('tab3-c-input');
const tab3CSlider = document.getElementById('tab3-c-slider');
const tab3B = document.getElementById('tab3-b');
const tab3A = document.getElementById('tab3-a');
const tab3XAtC = document.getElementById('tab3-xc');
const tab3Diagram = document.getElementById('tab3-diagram');
const tab3Ctx = tab3Diagram.getContext('2d');

const format3 = (value) => Number.isFinite(value) ? value.toFixed(3) : '---';
function computeFromRadiusTheta(radius, thetaDeg) {
  // 入力角度は 0〜90° の範囲を許容。その値を 360° から引いた角度で計算する
  if (!Number.isFinite(radius) || !Number.isFinite(thetaDeg) || radius <= 0 || thetaDeg < 0 || thetaDeg >= 90) {
    return { a: NaN, b: NaN, thetaRad: NaN };
  }

  // 内部計算用の角度（接線は右上方向に開く）
  const thetaCalcDeg = 360 - thetaDeg;
  const thetaRad = thetaCalcDeg * Math.PI / 180;
  const sinAngle = Math.sin(thetaRad);
  const cosAngle = Math.cos(thetaRad);

  // 接点座標（ワールド座標系）
  const tangentX = radius * cosAngle;
  const tangentY = radius * sinAngle;

  // A: 円の中心から接点までの水平距離（x 座標）
  const a = tangentX;
  // B: 円の下端（y = -radius）から接点までの縦距離
  const b = radius + tangentY;

  return {
    a,
    b,
    thetaRad,
    tangentPoint: { x: tangentX, y: tangentY },
  };
}

let isSyncingTab3 = false;

function updateTab3Outputs() {
  if (isSyncingTab3) return;
  isSyncingTab3 = true;

  const radiusVal = Number(tab3RadiusInput.value);
  let thetaDeg = Number(tab3ThetaInput.value);
  const rawCVal = Number(tab3CInput.value);
  const cVal = Number.isFinite(rawCVal) ? Math.min(rawCVal, 50) : rawCVal;

  if (Number.isFinite(radiusVal)) {
    tab3RadiusSlider.max = Math.max(Number(tab3RadiusSlider.max), radiusVal);
    tab3RadiusSlider.value = radiusVal;
  }

  if (Number.isFinite(thetaDeg)) {
    tab3ThetaSlider.value = thetaDeg;
  }

  if (Number.isFinite(cVal)) {
    tab3CSlider.value = cVal;
    if (rawCVal > 50) {
      tab3CInput.value = cVal.toFixed(1);
    }
  }

  const { a, b, thetaRad, tangentPoint } = computeFromRadiusTheta(radiusVal, thetaDeg);

  let xAtC = NaN;
  let cLinePoint = null;
  let yFromBottom = NaN;

  if (
    Number.isFinite(radiusVal) &&
    Number.isFinite(thetaRad) &&
    radiusVal > 0 &&
    thetaDeg >= 0 &&
    thetaDeg < 90 &&
    Number.isFinite(cVal) &&
    Number.isFinite(b) &&
    cVal <= 50 &&
    cVal >= b
  ) {
    // C の高さ（円の中心を 0、上が +、下が −）に変換
    const yTarget = cVal - radiusVal;
    yFromBottom = yTarget;

    const sinTheta = Math.sin(thetaRad);
    const cosTheta = Math.cos(thetaRad);

    // 接線の方程式 : cosθ * x + sinθ * y = r
    // y = yTarget を代入して x を解く
    if (Math.abs(cosTheta) > 1e-8) {
      xAtC = (radiusVal - sinTheta * yTarget) / cosTheta;
      cLinePoint = { x: xAtC, y: yFromBottom };
    }
  }

  tab3B.textContent = format3(b);
  tab3A.textContent = format3(a);
  tab3XAtC.textContent = format3(xAtC);

  drawTab3Diagram({
    radiusVal,
    aVal: a,
    bVal: b,
    thetaDeg,
    thetaRad,
    tangentPoint,
    cVal,
    xAtC,
    cLinePoint,
    yFromBottom,
  });

  isSyncingTab3 = false;
}

const bindSync = (inputEl, sliderEl) => {
  inputEl.addEventListener('input', () => {
    const val = Number(inputEl.value);
    if (Number.isFinite(val)) {
      sliderEl.value = val;
    }
    updateTab3Outputs();
  });

  sliderEl.addEventListener('input', () => {
    const val = Number(sliderEl.value);
    if (inputEl.step && inputEl.step.includes('.')) {
      const digits = inputEl.step.split('.')[1].length;
      inputEl.value = val.toFixed(digits);
    } else {
      inputEl.value = val;
    }
    updateTab3Outputs();
  });
};

const finalizeWithStep = (inputEl) => {
  const val = Number(inputEl.value);
  if (!Number.isFinite(val)) {
    inputEl.value = '';
    return;
  }

  const digits = inputEl.step && inputEl.step.includes('.')
    ? inputEl.step.split('.')[1].length
    : 0;
  inputEl.value = val.toFixed(digits);
};

tab3RadiusInput.addEventListener('blur', () => {
  finalizeWithStep(tab3RadiusInput);
  updateTab3Outputs();
});
tab3ThetaInput.addEventListener('blur', () => {
  finalizeWithStep(tab3ThetaInput);
  updateTab3Outputs();
});
tab3CInput.addEventListener('blur', () => {
  finalizeWithStep(tab3CInput);
  updateTab3Outputs();
});

bindSync(tab3RadiusInput, tab3RadiusSlider);
bindSync(tab3ThetaInput, tab3ThetaSlider);
bindSync(tab3CInput, tab3CSlider);
updateTab3Outputs();

function drawTab3Diagram(values) {
  const {
    radiusVal,
    aVal,
    bVal,
    thetaDeg,
    thetaRad,
    tangentPoint,
    cVal,
    xAtC,
    cLinePoint,
    yFromBottom,
  } = values;
  tab3Ctx.clearRect(0, 0, tab3Diagram.width, tab3Diagram.height);

  if (!Number.isFinite(radiusVal) || !Number.isFinite(thetaRad) || radiusVal <= 0 || thetaDeg < 0 || thetaDeg >= 90) {
    tab3Ctx.fillStyle = '#444';
    tab3Ctx.font = '28px sans-serif';
    tab3Ctx.textAlign = 'center';
    tab3Ctx.fillText('半径と角度を入力すると図が表示されます', tab3Diagram.width / 2, tab3Diagram.height / 2);
    return;
  }

  const width = tab3Diagram.width;
  const height = tab3Diagram.height;

  const baseCircleRadius = Math.min(width, height) * 0.32;
  const unitPerPixel = radiusVal > 0 ? (radiusVal / baseCircleRadius) : 1;
  const radiusPx = baseCircleRadius;

  const toCanvas = (xVal, yVal) => ({
    x: width * 0.44 + (xVal / unitPerPixel),
    y: height * 0.52 - (yVal / unitPerPixel),
  });

  const center = toCanvas(0, 0);
  const tangent = tangentPoint || { x: radiusVal, y: 0 };
  const tangentCanvas = toCanvas(tangent.x, tangent.y);
  const bottomCanvas = toCanvas(tangent.x, -radiusVal);
  const yFromBottomCanvas = Number.isFinite(yFromBottom) ? toCanvas(0, yFromBottom) : null;
  const cLinePointCanvas = cLinePoint ? toCanvas(cLinePoint.x, cLinePoint.y) : null;

   // ★ここだけ差し替え
  const dir = { x: -Math.sin(thetaRad), y: Math.cos(thetaRad) };
  const lineLength = radiusPx * 1.6;
  const lineStart = tangentCanvas;
  const lineEnd = {
    x: tangentCanvas.x + dir.x * lineLength,
    y: tangentCanvas.y - dir.y * lineLength,
  };

  tab3Ctx.save();
  tab3Ctx.strokeStyle = '#c4ccd8';
  tab3Ctx.setLineDash([10, 10]);
  tab3Ctx.lineWidth = 2.5;
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(center.x, 18);
  tab3Ctx.lineTo(center.x, height - 18);
  tab3Ctx.moveTo(22, center.y);
  tab3Ctx.lineTo(width - 22, center.y);
  tab3Ctx.stroke();
  tab3Ctx.restore();

  if (yFromBottomCanvas) {
    tab3Ctx.save();
    tab3Ctx.strokeStyle = '#e58a8a';
    tab3Ctx.setLineDash([8, 6]);
    tab3Ctx.lineWidth = 2;
    tab3Ctx.beginPath();
    tab3Ctx.moveTo(22, yFromBottomCanvas.y);
    tab3Ctx.lineTo(width - 22, yFromBottomCanvas.y);
    tab3Ctx.stroke();
    tab3Ctx.restore();
  }

  tab3Ctx.save();
  tab3Ctx.lineWidth = 4;
  tab3Ctx.strokeStyle = '#111';
  tab3Ctx.beginPath();
  tab3Ctx.arc(center.x, center.y, radiusPx, 0, Math.PI * 2);
  tab3Ctx.stroke();
  tab3Ctx.restore();

  tab3Ctx.save();
  tab3Ctx.strokeStyle = '#222';
  tab3Ctx.lineWidth = 5;
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(lineStart.x, lineStart.y);
  tab3Ctx.lineTo(lineEnd.x, lineEnd.y);
  tab3Ctx.stroke();
  tab3Ctx.restore();

  tab3Ctx.save();
  tab3Ctx.fillStyle = '#1f2d3d';
  tab3Ctx.beginPath();
  tab3Ctx.arc(center.x, center.y, 7, 0, Math.PI * 2);
  tab3Ctx.arc(tangentCanvas.x, tangentCanvas.y, 6, 0, Math.PI * 2);
  tab3Ctx.fill();
  tab3Ctx.font = '22px sans-serif';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText('原点（円の中心）', center.x + 12, center.y - 10);
  tab3Ctx.fillText('接点', tangentCanvas.x + 10, tangentCanvas.y - 10);
  tab3Ctx.restore();

  if (cLinePointCanvas) {
    tab3Ctx.save();
    tab3Ctx.fillStyle = '#c0392b';
    tab3Ctx.beginPath();
    tab3Ctx.arc(cLinePointCanvas.x, cLinePointCanvas.y, 7, 0, Math.PI * 2);
    tab3Ctx.fill();
    tab3Ctx.restore();
  }

  tab3Ctx.save();
  tab3Ctx.fillStyle = '#222';
  tab3Ctx.font = '28px sans-serif';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText(`角度 θ: ${thetaDeg.toFixed(2)}°`, 28, 44);
  tab3Ctx.fillText(`半径 r: ${radiusVal.toFixed(3)}`, 28, 76);
  if (yFromBottomCanvas && Number.isFinite(cVal)) {
    tab3Ctx.fillText(`C (円底からの Y): ${format3(cVal)}`, 28, yFromBottomCanvas.y - 12);
  }

  const bottomLabelY = (bottomCanvas.y + tangentCanvas.y) / 2;
  tab3Ctx.fillText(`A (接点 x): ${format3(aVal)}`, tangentCanvas.x + 12, tangentCanvas.y - 28);
  tab3Ctx.fillText(`B (底→接点の縦距離): ${format3(bVal)}`, bottomCanvas.x + 12, bottomLabelY);
  if (cLinePointCanvas) {
    tab3Ctx.fillText(`X (斜線と Y=C の交点): ${format3(xAtC)}`, cLinePointCanvas.x + 12, cLinePointCanvas.y - 16);
  }

  const toUnits = (point) => ({
    x: (point.x - center.x) * unitPerPixel,
    y: -(point.y - center.y) * unitPerPixel,
  });
  const formatSigned = (val) => `${val >= 0 ? '+' : ''}${format3(val)}`;
  const relativePoints = [
    { label: '接点', point: tangentCanvas },
    { label: '円底（接点直下）', point: bottomCanvas },
  ];
  if (cLinePointCanvas) {
    relativePoints.push({ label: 'Y=C での斜線交点', point: cLinePointCanvas });
  }

  tab3Ctx.font = '22px sans-serif';
  tab3Ctx.fillStyle = '#1f2d3d';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText('中心原点からの座標値（+X: 右 / +Y: 上）', 28, height - 92);
  relativePoints.forEach((item, idx) => {
    const coord = toUnits(item.point);
    const lineY = height - 64 + idx * 24;
    tab3Ctx.fillText(`${item.label}: x ${formatSigned(coord.x)}, y ${formatSigned(coord.y)}`, 28, lineY);
  });

  tab3Ctx.restore();
}
</script>
</body>
</html>
