<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta name="format-detection" content="telephone=no">
  <title>2D-CAD Prototype</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f0f0f0; display: block; }
    #angle-panel {
      position: absolute;
      top: 48px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1;
      background: #ffffff;
      padding: 10px 16px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12);
      white-space: nowrap;
    }
    #radius-panel {
      position: absolute;
      z-index: 1;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 48px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.18);
      white-space: nowrap;
    }
    #radius-panel input {
      font-size: 48px;
      padding: 12px 18px;
    }
    .box {
      margin-bottom: 10px;
    }
.tabs-wrapper {
  margin-top: 14px;
}

#tabs { display:flex; background:#ddd; padding: 54px 10px; gap: 8px; }
.tab-button {
  flex: 1;
  padding: 63px 18px;
  cursor: pointer;
  border: none;
  background: #ccc;
  font-size: 36px;
}
.tab-button.active { background:#fff; border-bottom:2px solid #000; }
.tab-content { display:none; }
.tab-content.active { display:block; }

.tab-section {
  max-width: 980px;
  margin: 20px auto;
  padding: 18px 22px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  font-size: 32px;
  line-height: 1.4;
}

.tab-section h2 {
  margin: 0 0 12px;
  font-size: 36px;
}

.input-row {
  display: grid;
  grid-template-columns: 180px 220px 1fr;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
}

.input-row input[type="number"] {
  font-size: 32px;
  padding: 8px 12px;
}

.input-row input[type="range"] {
  width: 100%;
  accent-color: #1f73ff;
}

.result-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 16px;
  margin-top: 12px;
}

.result-card {
  padding: 12px 16px;
  background: #f8f9fb;
  border-radius: 10px;
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.04);
}

.result-card .label {
  font-weight: bold;
  color: #1f2d3d;
}

.result-card .value {
  font-size: 38px;
  display: block;
  margin-top: 6px;
  letter-spacing: 0.02em;
}

    #calc1 {
      font-size: 48px;
    }
    #angle-panel label {
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 48px;
    }
    #angle-panel input[type="number"] {
      font-size: 48px;
      padding: 12px 18px;
    }
    #angle-panel input[type="range"] {
      width: 360px;
      accent-color: #1f73ff;
    }

#tri-center {
  width:100%;
  display:flex;
  justify-content:center;
  margin-top:20px;
}
#triView {
  border:1px solid #aaa;
  background:#fff;
}
    .triangle {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-top: 100px solid #c0d0ff;
    }
    #angle2-panel label {
      font-size: 32px;
    }
    #angle2-panel input {
      font-size: 32px;
      padding: 8px 12px;
    }
    #angle2-panel > div {
      font-size: 32px;
    }
    #angle2-panel #phiVal,
    #angle2-panel #alpha {
      font-size: 32px;
    }
  </style>
</head>
<body>
  <div class="tabs-wrapper">
    <div id="tabs">
      <button class="tab-button active" data-tab="calc1">A/B CAD</button>
      <button class="tab-button" data-tab="calc2">2.5D Angle</button>
      <button class="tab-button" data-tab="calc3">TouchPoint</button>
    </div>
  </div>
<div id="calc1" class="tab-content active">
  <div id="angle-panel">
    <label>
      角度（度数）:
      <input id="angle-input" type="number" value="0" min="0" max="179">
      <input id="angle-slider" type="range" value="0" min="0" max="179">
    </label>
  </div>
  <div id="radius-panel">
    <label>
      半径:
      <input id="radius-input" type="number" value="3.0" min="0" step="0.1" max="999">
    </label>
  </div>
  <canvas id="cad"></canvas>

  <script>
    const canvas = document.getElementById("cad");
    const ctx = canvas.getContext("2d");
    const angleInput = document.getElementById("angle-input");
    const angleSlider = document.getElementById("angle-slider");
    const radiusInput = document.getElementById("radius-input");
    const radiusPanel = document.getElementById("radius-panel");
    let angleDeg = Number(angleInput.value) || 0;
    const basePixelRadius = 240;
    let logicalRadius = Number(radiusInput.value) || 3;
    let bLabelFixedX = null;
    const setAngle = (value) => {
      angleDeg = Number(value) || 0;
      angleInput.value = angleDeg;
      angleSlider.value = angleDeg;
      draw();
    };
    angleInput.addEventListener("input", () => setAngle(angleInput.value));
    angleSlider.addEventListener("input", () => setAngle(angleSlider.value));
    const updateRadiusFromInput = () => {
      const radiusValue = Number(radiusInput.value);
      if (Number.isFinite(radiusValue)) {
        logicalRadius = radiusValue;
        draw();
      }
    };

    const finalizeRadiusInput = () => {
      const radiusValue = Number(radiusInput.value);
      const roundedRadius = Number.isFinite(radiusValue)
        ? Math.round(radiusValue * 10) / 10
        : 0;
      logicalRadius = roundedRadius;
      radiusInput.value = roundedRadius.toFixed(1);
      draw();
    };

    radiusInput.addEventListener("input", updateRadiusFromInput);
    radiusInput.addEventListener("blur", finalizeRadiusInput);

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }
    window.addEventListener("resize", resize);

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000";

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      // 円のピクセル半径は常に固定
      const baseLogicalRadius = 3;
      const radius = basePixelRadius;
      // 入力角度は「垂直からの傾き」として扱い、
      // 内部計算では (90° + 入力角度) を用いる
      const angleRad = (90 + angleDeg) * Math.PI / 180;
      const half = angleRad / 2;
      const sinHalfRaw = Math.sin(half);
      const sinHalf = Math.abs(sinHalfRaw) < 1e-6 ? (sinHalfRaw >= 0 ? 1e-6 : -1e-6) : sinHalfRaw;

      const dimensionRadius = logicalRadius || 0;
      // A = r * cot(θ/2) = r * cos(θ/2) / sin(θ/2)
      const dimensionA = dimensionRadius * Math.cos(half) / sinHalf;
      // B は従来通り: B = r * (1 + cos θ)
      const dimensionB = dimensionRadius * (1 + Math.cos(angleRad));

      const d = radius / sinHalf;
      const cornerX = centerX - d * Math.cos(half);
      const cornerY = centerY - d * Math.sin(half);
      const tangentLength = Math.sqrt(Math.max(0, d * d - radius * radius));
      const horizontalTangentX = cornerX + tangentLength;
      const angledTangentX = cornerX + tangentLength * Math.cos(angleRad);
      const angledTangentY = cornerY + tangentLength * Math.sin(angleRad);
      if (radiusPanel) {
        radiusPanel.style.left = `${centerX + 16}px`;
        radiusPanel.style.top = `${(centerY + cornerY) / 2 - 10}px`;
      }

      // 円
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.stroke();

      // 垂直線（中心から水平線まで）
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX, cornerY);
      ctx.stroke();

      const extension = radius * 2;

      // 右向きの線（接点からさらに延長）
      ctx.beginPath();
      ctx.moveTo(cornerX, cornerY);
      ctx.lineTo(horizontalTangentX + extension, cornerY);
      ctx.stroke();

      // α度の線（接点からさらに延長）
      ctx.beginPath();
      ctx.moveTo(cornerX, cornerY);
      ctx.lineTo(
        cornerX + (tangentLength + extension) * Math.cos(angleRad),
        cornerY + (tangentLength + extension) * Math.sin(angleRad)
      );
      ctx.stroke();

      // 接点の座標（斜め線と円の接点）
      const tangentX = cornerX + tangentLength * Math.cos(angleRad);
      const tangentY = cornerY + tangentLength * Math.sin(angleRad);

      // 円の一番下（中心直下の水平線）
      const bottomY = centerY + radius;

      const verticalPx = bottomY - tangentY;
      const horizontalPx = centerX - tangentX;

      const unitPerPixel = (logicalRadius && radius) ? (logicalRadius / radius) : 0;
      const verticalValue = verticalPx * unitPerPixel;
      const horizontalValue = horizontalPx * unitPerPixel;

      // 寸法値を小数点以下 3 桁で表示
      ctx.save();
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#333";
      ctx.textBaseline = "middle";

      ctx.restore();

      // A/B 寸法表示
      ctx.save();
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#333";
      ctx.textBaseline = "middle";

      // A: 上側水平線中央
      ctx.textAlign = "center";
      ctx.fillText(
        `A: ${dimensionA.toFixed(3)}`,
        (cornerX + centerX) / 2,
        cornerY - 20
      );

      // B: 角と接点の中間付近（左上寄り）
      ctx.textAlign = "right";
      if (bLabelFixedX === null) {
        bLabelFixedX = cornerX - 32;
      }
      ctx.fillText(
        `B: ${dimensionB.toFixed(3)}`,
        bLabelFixedX,
        (cornerY + tangentY) / 2 - 10
      );

      ctx.restore();
    }

    resize();
  </script>
</div>
  <div id="calc2" class="tab-content">
  <div id="angle2-panel" style="margin: 10px auto; text-align: center; width: fit-content;">
    <label>θ（初期角度）: <input id="theta" type="number" min="0" max="90" value="20">°</label><br>
    <label>φ（回転角）: <input id="phi" type="range" min="0" max="90" value="0"> <span id="phiVal">0</span></label><br>
    <div>見かけ角 α（度）: <span id="alpha">---</span></div>
    <div style="font-size: 12px; margin-top: 6px; line-height: 1.5; text-align: left;">
      <div>・回転角度 φ は X 軸に対する回転指示角。</div>
      <div>・直角三角形は垂直辺（右辺）を軸に回転。</div>
      <div>・見かけ角 α は斜辺の傾き θ と φ の組み合わせで決まる正面からの角度。</div>
    </div>
  </div>
  <div id="tri-center">
    <canvas id="triView" width="500" height="400"></canvas>
  </div>
</div>
<div id="calc3" class="tab-content">
  <div class="tab-section">
    <h2>円の半径と角度から接点座標を計算</h2>
    <div class="input-row">
      <div>半径 (r):</div>
      <input id="tab3-radius-input" type="number" value="3.0" min="0.0" step="0.1">
      <input id="tab3-radius-slider" type="range" min="0.0" max="100" step="0.1" value="3.0">
    </div>
    <div class="input-row">
      <div>角度（度）:</div>
      <input id="tab3-theta-input" type="number" value="0.0" min="0" max="89.9" step="0.1">
      <input id="tab3-theta-slider" type="range" min="0" max="89.9" step="0.1" value="0.0">
    </div>
    <div class="result-grid">
      <div class="result-card">
        <div class="label">A</div>
        <span class="value" id="tab3-a">---</span>
      </div>
      <div class="result-card">
        <div class="label">B</div>
        <span class="value" id="tab3-b">---</span>
      </div>
    </div>
    <div style="margin-top: 10px; font-size: 22px; color: #445;">
      入力と出力はすべて小数点以下 3 位に丸めて表示します。角度 0° では円の右端に垂直線、角度が増えると左上へ傾きます。
    </div>
    <div id="tab3-diagram-wrapper" style="margin-top: 24px; text-align: center;">
      <canvas id="tab3-diagram" width="1100" height="760" style="max-width: 100%; border: 1px solid #ccc; background: #fafafa;"></canvas>
    </div>
  </div>
</div>

<script>
document.querySelectorAll(".tab-button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    btn.classList.add("active");
    document.getElementById(btn.dataset.tab).classList.add("active");
  });
});

const thetaInput = document.getElementById('theta');
const phiInput = document.getElementById('phi');

thetaInput.addEventListener('input', updateAngle2);
phiInput.addEventListener('input', updateAngle2);

function formatDMS(deg, secondsDecimals = 1) {
  const sign = deg < 0 ? '-' : '';
  const absDeg = Math.abs(deg);
  let d = Math.floor(absDeg);
  let minFloat = (absDeg - d) * 60;
  let m = Math.floor(minFloat);
  let s = (minFloat - m) * 60;

  const roundingFactor = 10 ** secondsDecimals;
  s = Math.round(s * roundingFactor) / roundingFactor;
  if (s >= 60) {
    s -= 60;
    m += 1;
  }
  if (m >= 60) {
    m -= 60;
    d += 1;
  }

  let sStr = s.toFixed(secondsDecimals);
  if (secondsDecimals > 0) {
    sStr = sStr.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
  }
  const [sInt, sFrac] = sStr.split('.');
  const secIntPadded = sInt.padStart(2, '0');
  const secFormatted = sFrac ? `${secIntPadded}.${sFrac}` : secIntPadded;

  const minFormatted = String(m).padStart(2, '0');
  return `${sign}${d}°${minFormatted}′${secFormatted}″`;
}

function updateAngle2() {
  const thetaDeg = parseFloat(thetaInput.value) || 0;
  const theta = thetaDeg * Math.PI / 180;
  const phiDeg = parseFloat(phiInput.value) || 0;
  const phi = phiDeg * Math.PI / 180;
  const alpha = Math.atan(Math.tan(theta) * Math.cos(phi)) * 180 / Math.PI;

  const displayedPhiDeg = 90 - phiDeg;

  document.getElementById('phiVal').innerText = formatDMS(displayedPhiDeg);
  document.getElementById('alpha').innerText = formatDMS(alpha);

  const canvas = document.getElementById('triView');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 直角は右下、垂直辺は右、斜辺は左になるように配置する
  // θ は垂直辺と斜辺のなす角として扱う
  const hypotenuse = 220;
  const vertical = hypotenuse * Math.cos(theta);
  const bottom = hypotenuse * Math.sin(theta);

  const cx = canvas.width / 2;
  const cy = canvas.height * 0.70;

  // 三角形の各頂点（回転前）
  const bottomRight = { x: cx + bottom / 2, y: cy }; // 直角
  const bottomLeft = { x: cx - bottom / 2, y: cy };  // 底辺左端（短辺側）
  const topRight = { x: bottomRight.x, y: cy - vertical }; // 垂直辺の上端

  // 垂直辺（右辺）を回転軸として扱う
  // 軸上の点（bottomRight, topRight）はそのままにし、左端のみ回転
  // ただし回転によって底辺の高さが変わらないよう、
  // y 座標は固定しつつ x のみを縮小させる（奥行き方向の圧縮を想定）
  const rotateAroundRightEdge = (point) => {
    const dx = point.x - bottomRight.x;
    return {
      x: bottomRight.x + dx * Math.cos(phi),
      y: point.y,
    };
  };

  const rpBottomRight = bottomRight;
  const rpTopRight = topRight;
  const rpBottomLeft = rotateAroundRightEdge(bottomLeft);

  ctx.beginPath();
  ctx.moveTo(rpBottomRight.x, rpBottomRight.y);
  ctx.lineTo(rpBottomLeft.x, rpBottomLeft.y);
  ctx.lineTo(rpTopRight.x, rpTopRight.y);
  ctx.closePath();
  ctx.fillStyle = '#c0d0ff';
  ctx.strokeStyle = '#003';
  ctx.lineWidth = 2;
  ctx.fill();
  ctx.stroke();

  // 回転軸である垂直辺を破線で示す
  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(rpBottomRight.x, rpBottomRight.y);
  ctx.lineTo(rpTopRight.x, rpTopRight.y);
  ctx.stroke();
  ctx.restore();

  // θ・φ・α の簡易ラベルを表示
  ctx.fillStyle = '#003';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(`θ: ${formatDMS(thetaDeg)}`, 20, 24);
  ctx.fillText(`φ: ${formatDMS(phiDeg)}`, 20, 42);
  ctx.fillText(`α: ${formatDMS(alpha)}`, 20, 60);
}
updateAngle2();

// ==== Tab3: 半径と角度から接点の A/B を計算 ====
const tab3RadiusInput = document.getElementById('tab3-radius-input');
const tab3RadiusSlider = document.getElementById('tab3-radius-slider');
const tab3ThetaInput = document.getElementById('tab3-theta-input');
const tab3ThetaSlider = document.getElementById('tab3-theta-slider');
const tab3B = document.getElementById('tab3-b');
const tab3A = document.getElementById('tab3-a');
const tab3Diagram = document.getElementById('tab3-diagram');
const tab3Ctx = tab3Diagram.getContext('2d');

const format3 = (value) => Number.isFinite(value) ? value.toFixed(3) : '---';
function computeFromRadiusTheta(radius, thetaDeg) {
  if (!Number.isFinite(radius) || !Number.isFinite(thetaDeg) || radius <= 0 || thetaDeg < 0 || thetaDeg >= 90) {
    return { a: NaN, b: NaN, thetaRad: NaN };
  }

  const thetaRad = thetaDeg * Math.PI / 180;
  const sinAngle = Math.sin(thetaRad);
  const cosAngle = Math.cos(thetaRad);

  const tangentX = radius * cosAngle;
  const tangentY = -radius * sinAngle;

  // A: 円の中心から接点までの水平距離（x 座標）
  const a = tangentX;
  // B: 円の下端から接点までの縦距離
  const b = radius * (1 - sinAngle);

  return {
    a,
    b,
    thetaRad,
    tangentPoint: { x: tangentX, y: tangentY },
  };
}

let isSyncingTab3 = false;

function updateTab3Outputs() {
  if (isSyncingTab3) return;
  isSyncingTab3 = true;

  const radiusVal = Number(tab3RadiusInput.value);
  let thetaDeg = Number(tab3ThetaInput.value);

  if (Number.isFinite(radiusVal)) {
    tab3RadiusSlider.max = Math.max(Number(tab3RadiusSlider.max), radiusVal);
    tab3RadiusSlider.value = radiusVal;
  }

  if (Number.isFinite(thetaDeg)) {
    tab3ThetaSlider.value = thetaDeg;
  }

  const { a, b, thetaRad, tangentPoint } = computeFromRadiusTheta(radiusVal, thetaDeg);

  tab3B.textContent = format3(b);
  tab3A.textContent = format3(a);

  drawTab3Diagram({
    radiusVal,
    aVal: a,
    bVal: b,
    thetaDeg,
    thetaRad,
    tangentPoint,
  });

  isSyncingTab3 = false;
}

const bindSync = (inputEl, sliderEl) => {
  inputEl.addEventListener('input', () => {
    const val = Number(inputEl.value);
    if (Number.isFinite(val)) {
      sliderEl.value = val;
    }
    updateTab3Outputs();
  });

  sliderEl.addEventListener('input', () => {
    const val = Number(sliderEl.value);
    if (inputEl.step && inputEl.step.includes('.')) {
      const digits = inputEl.step.split('.')[1].length;
      inputEl.value = val.toFixed(digits);
    } else {
      inputEl.value = val;
    }
    updateTab3Outputs();
  });
};

const finalizeWithStep = (inputEl) => {
  const val = Number(inputEl.value);
  if (!Number.isFinite(val)) {
    inputEl.value = '';
    return;
  }

  const digits = inputEl.step && inputEl.step.includes('.')
    ? inputEl.step.split('.')[1].length
    : 0;
  inputEl.value = val.toFixed(digits);
};

tab3RadiusInput.addEventListener('blur', () => {
  finalizeWithStep(tab3RadiusInput);
  updateTab3Outputs();
});
tab3ThetaInput.addEventListener('blur', () => {
  finalizeWithStep(tab3ThetaInput);
  updateTab3Outputs();
});

bindSync(tab3RadiusInput, tab3RadiusSlider);
bindSync(tab3ThetaInput, tab3ThetaSlider);
updateTab3Outputs();

function drawTab3Diagram(values) {
  const { radiusVal, aVal, bVal, thetaDeg, thetaRad, tangentPoint } = values;
  tab3Ctx.clearRect(0, 0, tab3Diagram.width, tab3Diagram.height);

  if (!Number.isFinite(radiusVal) || !Number.isFinite(thetaRad) || radiusVal <= 0 || thetaDeg < 0 || thetaDeg >= 90) {
    tab3Ctx.fillStyle = '#444';
    tab3Ctx.font = '28px sans-serif';
    tab3Ctx.textAlign = 'center';
    tab3Ctx.fillText('半径と角度を入力すると図が表示されます', tab3Diagram.width / 2, tab3Diagram.height / 2);
    return;
  }

  const width = tab3Diagram.width;
  const height = tab3Diagram.height;

  const baseCircleRadius = Math.min(width, height) * 0.32;
  const unitPerPixel = radiusVal > 0 ? (radiusVal / baseCircleRadius) : 1;
  const radiusPx = baseCircleRadius;

  const toCanvas = (xVal, yVal) => ({
    x: width * 0.44 + (xVal / unitPerPixel),
    y: height * 0.52 - (yVal / unitPerPixel),
  });

  const center = toCanvas(0, 0);
  const tangent = tangentPoint || { x: radiusVal, y: 0 };
  const tangentCanvas = toCanvas(tangent.x, tangent.y);
  const bottomCanvas = toCanvas(tangent.x, -radiusVal);

  const dir = { x: Math.sin(thetaRad), y: -Math.cos(thetaRad) };
  const lineLength = radiusPx * 1.6;
  const lineStart = tangentCanvas;
  const lineEnd = {
    x: tangentCanvas.x + dir.x * lineLength,
    y: tangentCanvas.y + dir.y * lineLength,
  };

  tab3Ctx.save();
  tab3Ctx.strokeStyle = '#c4ccd8';
  tab3Ctx.setLineDash([10, 10]);
  tab3Ctx.lineWidth = 2.5;
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(center.x, 18);
  tab3Ctx.lineTo(center.x, height - 18);
  tab3Ctx.moveTo(22, center.y);
  tab3Ctx.lineTo(width - 22, center.y);
  tab3Ctx.stroke();
  tab3Ctx.restore();

  tab3Ctx.save();
  tab3Ctx.lineWidth = 4;
  tab3Ctx.strokeStyle = '#111';
  tab3Ctx.beginPath();
  tab3Ctx.arc(center.x, center.y, radiusPx, 0, Math.PI * 2);
  tab3Ctx.stroke();
  tab3Ctx.restore();

  tab3Ctx.save();
  tab3Ctx.strokeStyle = '#222';
  tab3Ctx.lineWidth = 5;
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(lineStart.x, lineStart.y);
  tab3Ctx.lineTo(lineEnd.x, lineEnd.y);
  tab3Ctx.stroke();
  tab3Ctx.restore();

  tab3Ctx.save();
  tab3Ctx.fillStyle = '#1f2d3d';
  tab3Ctx.beginPath();
  tab3Ctx.arc(center.x, center.y, 7, 0, Math.PI * 2);
  tab3Ctx.arc(tangentCanvas.x, tangentCanvas.y, 6, 0, Math.PI * 2);
  tab3Ctx.fill();
  tab3Ctx.font = '22px sans-serif';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText('原点（円の中心）', center.x + 12, center.y - 10);
  tab3Ctx.fillText('接点', tangentCanvas.x + 10, tangentCanvas.y - 10);
  tab3Ctx.restore();

  tab3Ctx.save();
  tab3Ctx.fillStyle = '#222';
  tab3Ctx.font = '28px sans-serif';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText(`角度 θ: ${thetaDeg.toFixed(2)}°`, 28, 44);
  tab3Ctx.fillText(`半径 r: ${radiusVal.toFixed(3)}`, 28, 76);

  const bottomLabelY = (bottomCanvas.y + tangentCanvas.y) / 2;
  tab3Ctx.fillText(`A (接点 x): ${format3(aVal)}`, tangentCanvas.x + 12, tangentCanvas.y - 28);
  tab3Ctx.fillText(`B (底→接点の縦距離): ${format3(bVal)}`, bottomCanvas.x + 12, bottomLabelY);

  const toUnits = (point) => ({
    x: (point.x - center.x) * unitPerPixel,
    y: -(point.y - center.y) * unitPerPixel,
  });
  const formatSigned = (val) => `${val >= 0 ? '+' : ''}${format3(val)}`;
  const relativePoints = [
    { label: '接点', point: tangentCanvas },
    { label: '円底（接点直下）', point: bottomCanvas },
  ];

  tab3Ctx.font = '22px sans-serif';
  tab3Ctx.fillStyle = '#1f2d3d';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText('中心原点からの座標値（+X: 右 / +Y: 上）', 28, height - 92);
  relativePoints.forEach((item, idx) => {
    const coord = toUnits(item.point);
    const lineY = height - 64 + idx * 24;
    tab3Ctx.fillText(`${item.label}: x ${formatSigned(coord.x)}, y ${formatSigned(coord.y)}`, 28, lineY);
  });

  tab3Ctx.restore();
}
</script>
</body>
</html>
