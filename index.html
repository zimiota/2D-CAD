<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta name="format-detection" content="telephone=no">
  <title>2D-CAD Prototype</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f0f0f0; display: block; }
    #control-panel {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      background: rgba(255, 255, 255, 0.92);
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.18);
      min-width: 880px;
    }
    #control-panel .input-row {
      grid-template-columns: 150px 200px 420px;
      margin-bottom: 10px;
      font-size: 26px;
    }
    #control-panel .input-row input[type="number"] {
      font-size: 26px;
    }
    #control-panel .input-row input[type="range"] {
      accent-color: #1f73ff;
    }
    #control-panel .result-grid {
      margin-top: 10px;
    }
    #control-panel .result-card .value {
      font-size: 32px;
    }
    .box {
      margin-bottom: 10px;
    }
#tabs { display:flex; background:#ddd; }
.tab-button { flex:1; padding:10px; cursor:pointer; border:none; background:#ccc; }
.tab-button.active { background:#fff; border-bottom:2px solid #000; }
.tab-content { display:none; }
.tab-content.active { display:block; }

.tab-section {
  max-width: 980px;
  margin: 20px auto;
  padding: 18px 22px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  font-size: 32px;
  line-height: 1.4;
}

.tab-section h2 {
  margin: 0 0 12px;
  font-size: 36px;
}

.input-row {
  display: grid;
  grid-template-columns: 180px 220px 1fr;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
}

.input-row input[type="number"] {
  font-size: 32px;
  padding: 8px 12px;
}

.input-row input[type="range"] {
  width: 100%;
  accent-color: #1f73ff;
}

.result-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 16px;
  margin-top: 12px;
}

.result-card {
  padding: 12px 16px;
  background: #f8f9fb;
  border-radius: 10px;
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.04);
}

.result-card .label {
  font-weight: bold;
  color: #1f2d3d;
}

.result-card .value {
  font-size: 38px;
  display: block;
  margin-top: 6px;
  letter-spacing: 0.02em;
}

#tri-center {
  width:100%;
  display:flex;
  justify-content:center;
  margin-top:20px;
}
#triView {
  border:1px solid #aaa;
  background:#fff;
}
    .triangle {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-top: 100px solid #c0d0ff;
    }
    #angle2-panel label {
      font-size: 32px;
    }
    #angle2-panel input {
      font-size: 32px;
      padding: 8px 12px;
    }
    #angle2-panel > div {
      font-size: 32px;
    }
    #angle2-panel #phiVal,
    #angle2-panel #alpha {
      font-size: 32px;
    }
  </style>
</head>
<body>
  <div id="tabs">
  <button class="tab-button active" data-tab="calc1">A/B CAD</button>
  <button class="tab-button" data-tab="calc2">2.5D Angle</button>
  <button class="tab-button" data-tab="calc3">TAB3</button>
</div>
<div id="calc1" class="tab-content active">
  <div id="control-panel">
    <div class="input-row">
      <div>半径 (r):</div>
      <input id="radius-input" type="number" value="3.000" min="0.001" step="0.001" max="999">
      <input id="radius-slider" type="range" value="3.000" min="0.001" max="100" step="0.001">
    </div>
    <div class="input-row">
      <div>角度 θ (度):</div>
      <input id="theta-input" type="number" value="90.000" min="0" max="179" step="0.001">
      <input id="theta-slider" type="range" value="90.000" min="0" max="179" step="0.001">
    </div>
    <div class="input-row">
      <div>A 値:</div>
      <input id="a-input" type="number" value="3.000" min="0.001" step="0.001">
      <input id="a-slider" type="range" value="3.000" min="0.001" max="100" step="0.001">
    </div>
    <div class="result-grid">
      <div class="result-card">
        <div class="label">A</div>
        <span class="value" id="calc1-a-value">---</span>
      </div>
      <div class="result-card">
        <div class="label">B</div>
        <span class="value" id="calc1-b-value">---</span>
      </div>
      <div class="result-card">
        <div class="label">C</div>
        <span class="value" id="calc1-c-value">---</span>
      </div>
      <div class="result-card">
        <div class="label">D</div>
        <span class="value" id="calc1-d-value">---</span>
      </div>
      <div class="result-card">
        <div class="label">θ (度)</div>
        <span class="value" id="calc1-theta-value">---</span>
      </div>
    </div>
  </div>
  <canvas id="cad"></canvas>

  <script>
    const canvas = document.getElementById("cad");
    const ctx = canvas.getContext("2d");
    const radiusInput = document.getElementById("radius-input");
    const radiusSlider = document.getElementById("radius-slider");
    const thetaInput = document.getElementById("theta-input");
    const thetaSlider = document.getElementById("theta-slider");
    const aInput = document.getElementById("a-input");
    const aSlider = document.getElementById("a-slider");
    const calc1AValue = document.getElementById("calc1-a-value");
    const calc1BValue = document.getElementById("calc1-b-value");
    const calc1CValue = document.getElementById("calc1-c-value");
    const calc1DValue = document.getElementById("calc1-d-value");
    const calc1ThetaValue = document.getElementById("calc1-theta-value");
    const basePixelRadius = 240;
    let bLabelFixedX = null;

    const state = {
      r: Number(radiusInput.value) || 3,
      thetaDeg: Number(thetaInput.value) || 90,
      A: Number(aInput.value) || 3,
      B: 0,
      C: 0,
      D: 0,
    };

    const clampTheta = (theta) => Math.min(179, Math.max(0, theta));

    const computeDimensions = (radius, thetaDeg) => {
      const thetaRad = (thetaDeg || 0) * Math.PI / 180;
      const half = thetaRad / 2;
      const sinHalfRaw = Math.sin(half);
      const sinHalf = Math.abs(sinHalfRaw) < 1e-6 ? (sinHalfRaw >= 0 ? 1e-6 : -1e-6) : sinHalfRaw;
      const cosHalf = Math.cos(half);
      const cosTheta = Math.cos(thetaRad);
      const sinTheta = Math.sin(thetaRad);

      const A = radius * cosHalf / sinHalf;
      const B = radius * (1 + cosTheta);

      const dDist = radius / sinHalf;
      const tangentLength = Math.sqrt(Math.max(0, dDist * dDist - radius * radius));
      const C = radius + dDist * sinHalf - tangentLength * sinTheta;
      const D = dDist * cosHalf - tangentLength * cosTheta;

      return { A, B, C, D };
    };

    const solveThetaFromA = (radius, targetA, maxIter = 80, epsilon = 1e-6) => {
      if (!Number.isFinite(radius) || radius <= 0 || !Number.isFinite(targetA) || targetA <= 0) {
        return NaN;
      }

      let low = 0;
      let high = 179;
      let bestTheta = clampTheta(state.thetaDeg);
      let bestDiff = Infinity;

      for (let i = 0; i < maxIter; i++) {
        const mid = (low + high) / 2;
        const { A } = computeDimensions(radius, mid);
        const diff = Math.abs(A - targetA);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestTheta = mid;
        }
        if (diff < epsilon) {
          break;
        }
        if (A > targetA) {
          low = mid;
        } else {
          high = mid;
        }
      }

      return bestTheta;
    };

    const updateStateFromTheta = () => {
      const derived = computeDimensions(state.r, state.thetaDeg);
      state.A = derived.A;
      state.B = derived.B;
      state.C = derived.C;
      state.D = derived.D;
    };

    const formatValue = (value) => Number.isFinite(value) ? value.toFixed(3) : "---";

    const syncUIWithState = () => {
      const limitedTheta = clampTheta(state.thetaDeg);
      state.thetaDeg = limitedTheta;

      radiusInput.value = Number.isFinite(state.r) ? state.r.toFixed(3) : "";
      radiusSlider.value = state.r;
      radiusSlider.max = Math.max(Number(radiusSlider.max), state.r);

      thetaInput.value = Number.isFinite(state.thetaDeg) ? state.thetaDeg.toFixed(3) : "";
      thetaSlider.value = state.thetaDeg;

      aInput.value = Number.isFinite(state.A) ? state.A.toFixed(3) : "";
      aSlider.value = state.A;
      aSlider.max = Math.max(Number(aSlider.max), state.A);

      calc1AValue.textContent = formatValue(state.A);
      calc1BValue.textContent = formatValue(state.B);
      calc1CValue.textContent = formatValue(state.C);
      calc1DValue.textContent = formatValue(state.D);
      calc1ThetaValue.textContent = Number.isFinite(state.thetaDeg) ? state.thetaDeg.toFixed(3) : "---";
    };

    const recomputeAndRender = () => {
      updateStateFromTheta();
      syncUIWithState();
      draw();
    };

    const handleRadiusChange = (value) => {
      const parsed = Number(value);
      if (!Number.isFinite(parsed) || parsed <= 0) {
        return;
      }
      state.r = parsed;
      recomputeAndRender();
    };

    const handleThetaChange = (value) => {
      const parsed = Number(value);
      if (!Number.isFinite(parsed)) {
        return;
      }
      state.thetaDeg = clampTheta(parsed);
      recomputeAndRender();
    };

    const handleAChange = (value) => {
      const parsed = Number(value);
      if (!Number.isFinite(parsed) || parsed <= 0) {
        return;
      }
      const solvedTheta = solveThetaFromA(state.r, parsed);
      if (!Number.isFinite(solvedTheta)) {
        return;
      }
      state.thetaDeg = clampTheta(solvedTheta);
      recomputeAndRender();
    };

    const bindInputPair = (inputEl, sliderEl, handler) => {
      inputEl.addEventListener("input", () => handler(inputEl.value));
      sliderEl.addEventListener("input", () => handler(sliderEl.value));
    };

    bindInputPair(radiusInput, radiusSlider, handleRadiusChange);
    bindInputPair(thetaInput, thetaSlider, handleThetaChange);
    bindInputPair(aInput, aSlider, handleAChange);

    recomputeAndRender();

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }
    window.addEventListener("resize", resize);

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000";

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      // 円のピクセル半径は常に固定
      const radius = basePixelRadius;
      const angleRad = (state.thetaDeg || 0) * Math.PI / 180;
      const half = angleRad / 2;
      const sinHalfRaw = Math.sin(half);
      const sinHalf = Math.abs(sinHalfRaw) < 1e-6 ? (sinHalfRaw >= 0 ? 1e-6 : -1e-6) : sinHalfRaw;

      const dimensionRadius = state.r || 0;
      const dimensionA = state.A;
      const dimensionB = state.B;

      const d = radius / sinHalf;
      const cornerX = centerX - d * Math.cos(half);
      const cornerY = centerY - d * Math.sin(half);
      const tangentLength = Math.sqrt(Math.max(0, d * d - radius * radius));
      const horizontalTangentX = cornerX + tangentLength;
      const angledTangentX = cornerX + tangentLength * Math.cos(angleRad);
      const angledTangentY = cornerY + tangentLength * Math.sin(angleRad);

      // 円
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.stroke();

      // 垂直線（中心から水平線まで）
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX, cornerY);
      ctx.stroke();

      const extension = radius * 2;

      // 右向きの線（接点からさらに延長）
      ctx.beginPath();
      ctx.moveTo(cornerX, cornerY);
      ctx.lineTo(horizontalTangentX + extension, cornerY);
      ctx.stroke();

      // α度の線（接点からさらに延長）
      ctx.beginPath();
      ctx.moveTo(cornerX, cornerY);
      ctx.lineTo(
        cornerX + (tangentLength + extension) * Math.cos(angleRad),
        cornerY + (tangentLength + extension) * Math.sin(angleRad)
      );
      ctx.stroke();

      // 接点の座標（斜め線と円の接点）
      const tangentX = cornerX + tangentLength * Math.cos(angleRad);
      const tangentY = cornerY + tangentLength * Math.sin(angleRad);

      // 寸法値を小数点以下 3 桁で表示
      ctx.save();
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#333";
      ctx.textBaseline = "middle";

      ctx.restore();

      // A/B 寸法表示
      ctx.save();
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#333";
      ctx.textBaseline = "middle";

      // A: 上側水平線中央
      ctx.textAlign = "center";
      ctx.fillText(
        `A: ${dimensionA.toFixed(3)}`,
        (cornerX + centerX) / 2,
        cornerY - 20
      );

      // B: 角と接点の中間付近（左上寄り）
      ctx.textAlign = "right";
      if (bLabelFixedX === null) {
        bLabelFixedX = cornerX - 32;
      }
      ctx.fillText(
        `B: ${dimensionB.toFixed(3)}`,
        bLabelFixedX,
        (cornerY + tangentY) / 2 - 10
      );

      ctx.restore();
    }

    resize();
  </script>
</div>
  <div id="calc2" class="tab-content">
  <div id="angle2-panel" style="margin: 10px auto; text-align: center; width: fit-content;">
    <label>θ（初期角度）: <input id="theta" type="number" min="0" max="90" value="20">°</label><br>
    <label>φ（回転角）: <input id="phi" type="range" min="0" max="90" value="0"> <span id="phiVal">0</span></label><br>
    <div>見かけ角 α（度）: <span id="alpha">---</span></div>
    <div style="font-size: 12px; margin-top: 6px; line-height: 1.5; text-align: left;">
      <div>・回転角度 φ は X 軸に対する回転指示角。</div>
      <div>・直角三角形は垂直辺（右辺）を軸に回転。</div>
      <div>・見かけ角 α は斜辺の傾き θ と φ の組み合わせで決まる正面からの角度。</div>
    </div>
  </div>
  <div id="tri-center">
    <canvas id="triView" width="500" height="400"></canvas>
  </div>
</div>
<div id="calc3" class="tab-content">
  <div class="tab-section">
    <h2>円の半径と A から B・C・D を計算</h2>
    <div class="input-row">
      <div>半径 (r):</div>
      <input id="tab3-radius-input" type="number" value="3.000" min="0.001" step="0.001">
      <input id="tab3-radius-slider" type="range" min="0.001" max="100" step="0.001" value="3.000">
    </div>
    <div class="input-row">
      <div>A 値:</div>
      <input id="tab3-a-input" type="number" value="3.000" min="0.001" step="0.001">
      <input id="tab3-a-slider" type="range" min="0.001" max="100" step="0.001" value="3.000">
    </div>
    <div class="result-grid">
      <div class="result-card">
        <div class="label">B</div>
        <span class="value" id="tab3-b">---</span>
      </div>
      <div class="result-card">
        <div class="label">C</div>
        <span class="value" id="tab3-c">---</span>
      </div>
      <div class="result-card">
        <div class="label">D</div>
        <span class="value" id="tab3-d">---</span>
      </div>
    </div>
    <div style="margin-top: 10px; font-size: 22px; color: #445;">
      入力と出力はすべて小数点以下 3 位に丸めて表示します。
    </div>
    <div id="tab3-diagram-wrapper" style="margin-top: 24px; text-align: center;">
      <canvas id="tab3-diagram" width="1100" height="760" style="max-width: 100%; border: 1px solid #ccc; background: #fafafa;"></canvas>
    </div>
  </div>
</div>

<script>
document.querySelectorAll(".tab-button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    btn.classList.add("active");
    document.getElementById(btn.dataset.tab).classList.add("active");
  });
});

const thetaInput = document.getElementById('theta');
const phiInput = document.getElementById('phi');

thetaInput.addEventListener('input', updateAngle2);
phiInput.addEventListener('input', updateAngle2);

function formatDMS(deg, secondsDecimals = 1) {
  const sign = deg < 0 ? '-' : '';
  const absDeg = Math.abs(deg);
  let d = Math.floor(absDeg);
  let minFloat = (absDeg - d) * 60;
  let m = Math.floor(minFloat);
  let s = (minFloat - m) * 60;

  const roundingFactor = 10 ** secondsDecimals;
  s = Math.round(s * roundingFactor) / roundingFactor;
  if (s >= 60) {
    s -= 60;
    m += 1;
  }
  if (m >= 60) {
    m -= 60;
    d += 1;
  }

  let sStr = s.toFixed(secondsDecimals);
  if (secondsDecimals > 0) {
    sStr = sStr.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
  }
  const [sInt, sFrac] = sStr.split('.');
  const secIntPadded = sInt.padStart(2, '0');
  const secFormatted = sFrac ? `${secIntPadded}.${sFrac}` : secIntPadded;

  const minFormatted = String(m).padStart(2, '0');
  return `${sign}${d}°${minFormatted}′${secFormatted}″`;
}

function updateAngle2() {
  const thetaDeg = parseFloat(thetaInput.value) || 0;
  const theta = thetaDeg * Math.PI / 180;
  const phiDeg = parseFloat(phiInput.value) || 0;
  const phi = phiDeg * Math.PI / 180;
  const alpha = Math.atan(Math.tan(theta) * Math.cos(phi)) * 180 / Math.PI;

  const displayedPhiDeg = 90 - phiDeg;

  document.getElementById('phiVal').innerText = formatDMS(displayedPhiDeg);
  document.getElementById('alpha').innerText = formatDMS(alpha);

  const canvas = document.getElementById('triView');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 直角は右下、垂直辺は右、斜辺は左になるように配置する
  // θ は垂直辺と斜辺のなす角として扱う
  const hypotenuse = 220;
  const vertical = hypotenuse * Math.cos(theta);
  const bottom = hypotenuse * Math.sin(theta);

  const cx = canvas.width / 2;
  const cy = canvas.height * 0.70;

  // 三角形の各頂点（回転前）
  const bottomRight = { x: cx + bottom / 2, y: cy }; // 直角
  const bottomLeft = { x: cx - bottom / 2, y: cy };  // 底辺左端（短辺側）
  const topRight = { x: bottomRight.x, y: cy - vertical }; // 垂直辺の上端

  // 垂直辺（右辺）を回転軸として扱う
  // 軸上の点（bottomRight, topRight）はそのままにし、左端のみ回転
  // ただし回転によって底辺の高さが変わらないよう、
  // y 座標は固定しつつ x のみを縮小させる（奥行き方向の圧縮を想定）
  const rotateAroundRightEdge = (point) => {
    const dx = point.x - bottomRight.x;
    return {
      x: bottomRight.x + dx * Math.cos(phi),
      y: point.y,
    };
  };

  const rpBottomRight = bottomRight;
  const rpTopRight = topRight;
  const rpBottomLeft = rotateAroundRightEdge(bottomLeft);

  ctx.beginPath();
  ctx.moveTo(rpBottomRight.x, rpBottomRight.y);
  ctx.lineTo(rpBottomLeft.x, rpBottomLeft.y);
  ctx.lineTo(rpTopRight.x, rpTopRight.y);
  ctx.closePath();
  ctx.fillStyle = '#c0d0ff';
  ctx.strokeStyle = '#003';
  ctx.lineWidth = 2;
  ctx.fill();
  ctx.stroke();

  // 回転軸である垂直辺を破線で示す
  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(rpBottomRight.x, rpBottomRight.y);
  ctx.lineTo(rpTopRight.x, rpTopRight.y);
  ctx.stroke();
  ctx.restore();

  // θ・φ・α の簡易ラベルを表示
  ctx.fillStyle = '#003';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(`θ: ${formatDMS(thetaDeg)}`, 20, 24);
  ctx.fillText(`φ: ${formatDMS(phiDeg)}`, 20, 42);
  ctx.fillText(`α: ${formatDMS(alpha)}`, 20, 60);
}
updateAngle2();

// ==== Tab3: 半径と A から B/C/D を計算 ====
const tab3RadiusInput = document.getElementById('tab3-radius-input');
const tab3RadiusSlider = document.getElementById('tab3-radius-slider');
const tab3AInput = document.getElementById('tab3-a-input');
const tab3ASlider = document.getElementById('tab3-a-slider');
const tab3B = document.getElementById('tab3-b');
const tab3C = document.getElementById('tab3-c');
const tab3D = document.getElementById('tab3-d');
const tab3Diagram = document.getElementById('tab3-diagram');
const tab3Ctx = tab3Diagram.getContext('2d');

const format3 = (value) => Number.isFinite(value) ? value.toFixed(3) : '---';

function computeBCD(radius, aValue) {
  if (!Number.isFinite(radius) || !Number.isFinite(aValue) || radius <= 0 || aValue <= 0) {
    return { b: NaN, c: NaN, d: NaN };
  }

  const half = Math.atan(radius / aValue);
  const sinHalf = Math.sin(half);
  if (Math.abs(sinHalf) < 1e-9) {
    return { b: NaN, c: NaN, d: NaN };
  }

  const angleRad = half * 2;
  const cosHalf = Math.cos(half);
  const cosAngle = Math.cos(angleRad);
  const sinAngle = Math.sin(angleRad);

  const b = radius * (1 + cosAngle);

  const dDist = radius / sinHalf;
  const tangentLength = Math.sqrt(Math.max(0, dDist * dDist - radius * radius));

  const c = radius + dDist * sinHalf - tangentLength * sinAngle;
  const d = dDist * cosHalf - tangentLength * cosAngle;

  return { b, c, d };
}

function updateTab3Outputs() {
  const radiusVal = Number(tab3RadiusInput.value);
  const aVal = Number(tab3AInput.value);
  tab3RadiusInput.value = Number.isFinite(radiusVal) ? radiusVal.toFixed(3) : '';
  tab3AInput.value = Number.isFinite(aVal) ? aVal.toFixed(3) : '';

  if (Number.isFinite(radiusVal)) {
    tab3RadiusSlider.max = Math.max(Number(tab3RadiusSlider.max), radiusVal);
    tab3RadiusSlider.value = radiusVal;
  }

  if (Number.isFinite(aVal)) {
    tab3ASlider.max = Math.max(Number(tab3ASlider.max), aVal);
    tab3ASlider.value = aVal;
  }

  const { b, c, d } = computeBCD(radiusVal, aVal);
  tab3B.textContent = format3(b);
  tab3C.textContent = format3(c);
  tab3D.textContent = format3(d);

  drawTab3Diagram({ radiusVal, aVal, bVal: b, cVal: c, dVal: d });
}

const bindSync = (inputEl, sliderEl) => {
  inputEl.addEventListener('input', () => {
    const val = Number(inputEl.value);
    if (Number.isFinite(val)) {
      sliderEl.value = val;
    }
    updateTab3Outputs();
  });

  sliderEl.addEventListener('input', () => {
    const val = Number(sliderEl.value);
    inputEl.value = val.toFixed(3);
    updateTab3Outputs();
  });
};

bindSync(tab3RadiusInput, tab3RadiusSlider);
bindSync(tab3AInput, tab3ASlider);
updateTab3Outputs();

function drawTab3Diagram(values) {
  const { radiusVal, aVal, bVal, cVal, dVal } = values;
  tab3Ctx.clearRect(0, 0, tab3Diagram.width, tab3Diagram.height);

  if (!Number.isFinite(radiusVal) || !Number.isFinite(aVal) || radiusVal <= 0 || aVal <= 0) {
    tab3Ctx.fillStyle = '#444';
    tab3Ctx.font = '28px sans-serif';
    tab3Ctx.textAlign = 'center';
    tab3Ctx.fillText('半径と A を入力すると図が表示されます', tab3Diagram.width / 2, tab3Diagram.height / 2);
    return;
  }

  const width = tab3Diagram.width;
  const height = tab3Diagram.height;
  const radiusPx = 240;
  const unitPerPixel = radiusVal / radiusPx;

  const half = Math.atan(radiusVal / aVal);
  const angleRad = half * 2;
  const sinHalf = Math.sin(half);
  const cosHalf = Math.cos(half);

  const dDistPx = radiusPx / sinHalf;
  const tangentLength = Math.sqrt(Math.max(0, dDistPx * dDistPx - radiusPx * radiusPx));
  const bisectorAngle = Math.PI / 4; // 45° 方向を基準に、2 本の接線を同じ角度で配置

  const centerX = width * 0.45;
  const centerY = height * 0.60;
  const cornerX = centerX + dDistPx * Math.cos(bisectorAngle);
  const cornerY = centerY + dDistPx * Math.sin(bisectorAngle);

  const line1Angle = bisectorAngle + half;
  const line2Angle = bisectorAngle - half;

  const lineExtension = tangentLength + 120;
  const line1End = {
    x: cornerX + lineExtension * Math.cos(line1Angle),
    y: cornerY + lineExtension * Math.sin(line1Angle),
  };
  const line2End = {
    x: cornerX + lineExtension * Math.cos(line2Angle),
    y: cornerY + lineExtension * Math.sin(line2Angle),
  };

  const tangent1 = {
    x: cornerX + tangentLength * Math.cos(line1Angle),
    y: cornerY + tangentLength * Math.sin(line1Angle),
  };
  const tangent2 = {
    x: cornerX + tangentLength * Math.cos(line2Angle),
    y: cornerY + tangentLength * Math.sin(line2Angle),
  };

  // 円
  tab3Ctx.beginPath();
  tab3Ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
  tab3Ctx.strokeStyle = '#111';
  tab3Ctx.lineWidth = 3;
  tab3Ctx.stroke();

  // 半径線（中心→接点方向）
  const bisectorUnit = {
    x: (cornerX - centerX) / dDistPx,
    y: (cornerY - centerY) / dDistPx,
  };
  const circleOnBisector = {
    x: centerX + bisectorUnit.x * radiusPx,
    y: centerY + bisectorUnit.y * radiusPx,
  };
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(centerX, centerY);
  tab3Ctx.lineTo(circleOnBisector.x, circleOnBisector.y);
  tab3Ctx.strokeStyle = '#1f73ff';
  tab3Ctx.lineWidth = 2.5;
  tab3Ctx.stroke();

  // 接線 2 本（同じ角度）
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(cornerX, cornerY);
  tab3Ctx.lineTo(line1End.x, line1End.y);
  tab3Ctx.moveTo(cornerX, cornerY);
  tab3Ctx.lineTo(line2End.x, line2End.y);
  tab3Ctx.strokeStyle = '#225';
  tab3Ctx.lineWidth = 4;
  tab3Ctx.stroke();

  // 半径の延長線（角 bisector）
  tab3Ctx.save();
  tab3Ctx.setLineDash([10, 8]);
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(centerX, centerY);
  tab3Ctx.lineTo(cornerX, cornerY);
  tab3Ctx.strokeStyle = '#888';
  tab3Ctx.lineWidth = 2;
  tab3Ctx.stroke();
  tab3Ctx.restore();

  // A を bisector 上に描画
  const aLengthPx = aVal / unitPerPixel;
  const aStart = circleOnBisector;
  const aEnd = {
    x: aStart.x + bisectorUnit.x * aLengthPx,
    y: aStart.y + bisectorUnit.y * aLengthPx,
  };
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(aStart.x, aStart.y);
  tab3Ctx.lineTo(aEnd.x, aEnd.y);
  tab3Ctx.strokeStyle = '#d94fd4';
  tab3Ctx.lineWidth = 6;
  tab3Ctx.stroke();

  // C を示す垂線（角→円の接点方向）
  const cLengthPx = Number.isFinite(cVal) ? cVal / unitPerPixel : 0;
  const cDir = {
    x: Math.cos(line2Angle + Math.PI / 2),
    y: Math.sin(line2Angle + Math.PI / 2),
  };
  const cStart = tangent2;
  const cEnd = {
    x: cStart.x + cDir.x * cLengthPx,
    y: cStart.y + cDir.y * cLengthPx,
  };
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(cStart.x, cStart.y);
  tab3Ctx.lineTo(cEnd.x, cEnd.y);
  tab3Ctx.strokeStyle = '#ff7f11';
  tab3Ctx.lineWidth = 4;
  tab3Ctx.stroke();

  // D を示す水平線（角を基準に）
  const dLengthPx = Number.isFinite(dVal) ? dVal / unitPerPixel : 0;
  const dStart = { x: cornerX, y: cornerY };
  const dEnd = { x: dStart.x + dLengthPx, y: dStart.y };
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(dStart.x, dStart.y);
  tab3Ctx.lineTo(dEnd.x, dEnd.y);
  tab3Ctx.strokeStyle = '#11a861';
  tab3Ctx.lineWidth = 4;
  tab3Ctx.stroke();

  // B を示す短いマーカー（接点近く）
  const bLengthPx = Number.isFinite(bVal) ? bVal / unitPerPixel : 0;
  const bMarkerDir = { x: Math.cos(line1Angle), y: Math.sin(line1Angle) };
  const bStart = {
    x: tangent1.x - bMarkerDir.x * (bLengthPx * 0.15),
    y: tangent1.y - bMarkerDir.y * (bLengthPx * 0.15),
  };
  const bEnd = {
    x: bStart.x + bMarkerDir.x * (bLengthPx * 0.30),
    y: bStart.y + bMarkerDir.y * (bLengthPx * 0.30),
  };
  tab3Ctx.beginPath();
  tab3Ctx.moveTo(bStart.x, bStart.y);
  tab3Ctx.lineTo(bEnd.x, bEnd.y);
  tab3Ctx.strokeStyle = '#1b82f1';
  tab3Ctx.lineWidth = 6;
  tab3Ctx.stroke();

  // ラベル
  tab3Ctx.fillStyle = '#222';
  tab3Ctx.font = '28px sans-serif';
  tab3Ctx.textAlign = 'left';
  tab3Ctx.fillText(`角度 θ: ${(angleRad * 180 / Math.PI).toFixed(2)}°`, 40, 50);
  tab3Ctx.fillText(`半径 r: ${radiusVal.toFixed(3)}`, 40, 90);
  tab3Ctx.fillText(`A: ${format3(aVal)}`, aEnd.x + 10, aEnd.y - 10);
  tab3Ctx.fillText(`B: ${format3(bVal)}`, bEnd.x + 10, bEnd.y);
  tab3Ctx.fillText(`C: ${format3(cVal)}`, cEnd.x + 10, cEnd.y);
  tab3Ctx.fillText(`D: ${format3(dVal)}`, dEnd.x + 10, dEnd.y + 6);
}
</script>
</body>
</html>
